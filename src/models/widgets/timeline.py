'''
Our timeline object that stores plot points, arcs, and time skips.
These objects is displayed in the timelines widget, and store our mini widgets plot points, arcs, and time skips.
'''

import json
import os
import flet as ft
from styles.menu_option_style import Menu_Option_Style
from models.story import Story
from models.widget import Widget
from models.mini_widgets.timelines.arc import Arc
from handlers.verify_data import verify_data
import flet.canvas as cv
from styles.colors import colors


class Timeline(Widget):

    # Constructor. Requires title, owner widget, page reference, and optional data dictionary
    def __init__(self, title: str, page: ft.Page, directory_path: str, story: Story, data: dict=None):
        
        # Parent constructor
        super().__init__(
            title = title,  
            page = page,   
            directory_path = directory_path, 
            story = story,     
            data = data,  
        ) 


        # Verifies this object has the required data fields, and creates them if not
        verify_data(
            self,   # Pass in our own data so the function can see the actual data we loaded
            {
                'tag': "timeline",
                'filters': {   
                    'show_timeskips': True,
                    'show_plot_points': True,
                    'show_arcs': True,
                },        
                'information_display': {'visibility': True},
                'time_label': str,                          # Label for the time axis (any str they want)
                'start_date': str,                          # Start and end date of the branch, for timeline view
                'end_date': str,                            # Start and end date of the branch, for timeline view
                'color': "primary",                         # Color of the branch in the timeline
                'dropdown_is_expanded': True,               # If the branch dropdown is expanded on the rail
                'plot_points_dropdown_expanded': True,      # If the plotpoints section is expanded
                'arcs_dropdown_expanded': True,             # If the arcs section is expanded
                

                'plot_points': dict,                        # Dict of plot points in this branch
                'time_skips': dict,                         # Dict of time skips in this branch
                'arcs': dict,                               # Dict of arcs in this branch
                'connections': dict,                        # Connect points, arcs, branch, etc.???
                'rail_dropdown_is_expanded': True,          # If the rail dropdown is expanded  
                'description': str,
                'events': list,                             # Step by step of plot events through the arc. Call plot point??
                'involved_characters': list,
                'related_locations': list,
                'related_items': list,
                'divisions': 10,                            # Number of divisions on the timeline

                'left_edge_label': float,                   # Label for the left edge of the timeline
                'right_edge_label': float,                  # Label for the right edge of the timeline
            },
        ) 

        # For tracking mouse position on timeline when adding new items
        self.x_alignment: float = 0.00

        # Declare and create our information display, which is our timelines mini widget 
        self.information_display: ft.Container = None
        self.create_information_display()
        
        # Declare dicts of our data types   
        self.arcs: dict = {}        # TODO: No more infinite arcs
        self.plot_points: dict = {} 
        self.time_skips: dict = {}
        self.connections: dict = {}  # Needed????


        # Loads our three mini widgets into their dicts
        self.load_arcs()
        self.load_plot_points()
        
        # UI elements
        self.timeline_control = ft.GestureDetector(
            mouse_cursor=ft.MouseCursor.CLICK,
            expand=True,
            on_exit=self.on_exit,        
            on_tap=lambda e: self.information_display.toggle_visibility(value=True),
            hover_interval=20,
        )

        # Edges of our timeline
        self.timeline_left_edge = ft.GestureDetector(
            height=50,
            data=0,
            content=ft.VerticalDivider(color=ft.Colors.with_opacity(0.7, self.data.get('color', "primary")), thickness=3, width=3), 
            mouse_cursor=ft.MouseCursor.CLICK,
            on_exit=self.on_exit,
            on_enter=self.on_enter,
            on_tap=lambda e: self.information_display.toggle_visibility(value=True),
        )
        self.timeline_right_edge = ft.GestureDetector(
            height=50,
            data=200,
            content=ft.VerticalDivider(color=ft.Colors.with_opacity(0.7, self.data.get('color', "primary")), thickness=3, width=3), 
            mouse_cursor=ft.MouseCursor.CLICK,
            on_exit=self.on_exit,
            on_enter=self.on_enter,
            on_tap=lambda e: self.information_display.toggle_visibility(value=True),
        )

        # Dropdown on the rail. We don't use it here, let the rail handle it
        self.timeline_dropdown = None      # 'Timeline_Dropdown'
        
        # Builds/reloads our timeline UI
        self.reload_widget()

    # Called in the constructor
    def create_information_display(self):
        ''' Creates our timeline information display mini widget '''
        from models.mini_widgets.timelines.timeline_information_display import Timeline_Information_Display
        
        self.information_display = Timeline_Information_Display(
            title=self.title,
            owner=self,
            father=self,
            page=self.p,
            key="none",     # Not used, but its required so just whatever works
            data=None,      # It uses our data, so we don't need to give it a copy that we would have to constantly maintain
        )
        # Add to our mini widgets so it shows up in the UI
        self.mini_widgets.append(self.information_display)

    # Called in the constructor
    def load_arcs(self):
        ''' Loads branches from data into self.branches  '''

        # Looks up our branches in our data, then passes in that data to create a live object
        for key, data in self.data['arcs'].items():
            self.arcs[key] = Arc(
                title=key, 
                owner=self, 
                father=self,
                page=self.p, 
                key="arcs",
                data=data
            )
            self.mini_widgets.append(self.arcs[key])  # Branches need to be in the owners mini widgets list to show up in the UI
    
    # Called in the constructor
    def load_plot_points(self):
        ''' Loads plotpoints from data into self.plotpoints  '''
        from models.mini_widgets.timelines.plot_point import Plot_Point

        # Looks up our plotpoints in our data, then passes in that data to create a live object
        for key, data in self.data['plot_points'].items():
            self.plot_points[key] = Plot_Point(
                title=key, 
                owner=self, 
                father=self,
                page=self.p, 
                key="plot_points", 
                data=data
            )
            self.mini_widgets.append(self.plot_points[key])  # Plot points need to be in the owners mini widgets list to show up in the UI
        
    
    # Called when creating a new arc
    def create_arc(self, title: str):
        ''' Creates a new arc inside of our timeline object, and updates the data to match '''
        from models.mini_widgets.timelines.arc import Arc

        new_arc = Arc(
            title=title, 
            owner=self, 
            father=self,
            page=self.p, 
            key="arcs", 
            x_alignment=self.x_alignment,
            data=None
        )

        # Add our new Arc mini widget object to our arcs dict, and to our owners mini widgets
        self.arcs[new_arc.title] = new_arc
        self.mini_widgets.append(new_arc)

        # Apply our changes in the UI
        self.story.active_rail.content.reload_rail()
        self.reload_widget()
        
    # Called when creating a new plotpoint
    def create_plot_point(self, title: str):
        ''' Creates a new plotpoint inside of our timeline object, and updates the data to match '''
        from models.mini_widgets.timelines.plot_point import Plot_Point

        new_plot_point = Plot_Point(
            title=title, 
            owner=self, 
            father=self,
            page=self.p, 
            key="plot_points", 
            x_alignment=self.x_alignment,
            data=None
        )
        # Add our new Plot Point mini widget object to our plot_points dict, and to our owners mini widgets
        self.plot_points[new_plot_point.title] = new_plot_point
        self.mini_widgets.append(new_plot_point)

        # Apply our changes in the UI
        self.story.active_rail.content.reload_rail()
        self.reload_widget()


    def delete_plot_point(self, plot_point):
        ''' Deletes a plot point from our timeline '''
        
        # Remove from our dict
        if plot_point.title in self.plot_points:
            self.plot_points.pop(plot_point.title)
            self.data['plot_points'].pop(plot_point.title, None)
            self.save_dict()

        # Apply changes
        self.reload_widget()

    def delete_arc(self, arc):
        ''' Deletes an arc from our timeline '''
        
        # Remove from our dict
        if arc.title in self.arcs:
            self.arcs.pop(arc.title)
            self.data['arcs'].pop(arc.title, None)
            self.save_dict()

        # Apply changes
        self.reload_widget()

    # Called when right clicking our controls for either timeline or an arc
    def get_menu_options(self) -> list[ft.Control]:

        # Color, rename, delete
        return [
            # Delete button
        
            Menu_Option_Style(
                on_click=self.new_item_clicked,
                data="arc",
                content=ft.Row([
                    ft.Icon(ft.Icons.CIRCLE_OUTLINED),
                    ft.Text("Arc", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                ])
            ),
            Menu_Option_Style(
                on_click=self.new_item_clicked,
                data="plot_point",
                content=ft.Row([
                    ft.Icon(ft.Icons.ADD_LOCATION_OUTLINED),
                    ft.Text("Plot Point", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                ])
            ),
            Menu_Option_Style(
                on_click=self.rename_clicked,
                content=ft.Row([
                    ft.Icon(ft.Icons.DRIVE_FILE_RENAME_OUTLINE_OUTLINED),
                    ft.Text(
                        "Rename", 
                        weight=ft.FontWeight.BOLD, 
                        color=ft.Colors.ON_SURFACE
                    ), 
                ]),
            ),
            # Color changing popup menu
            Menu_Option_Style(
                content=ft.PopupMenuButton(
                    expand=True,
                    tooltip="",
                    padding=None,
                    content=ft.Row(
                        expand=True,
                        controls=[
                            ft.Icon(ft.Icons.COLOR_LENS_OUTLINED, color=ft.Colors.PRIMARY),
                            ft.Text("Color", weight=ft.FontWeight.BOLD, color=ft.Colors.ON_SURFACE, expand=True), 
                            ft.Icon(ft.Icons.ARROW_DROP_DOWN_OUTLINED, color=ft.Colors.ON_SURFACE, size=16),
                        ]
                    ),
                    items=self.get_color_options()
                )
            ),
            Menu_Option_Style(
                on_click=lambda e: self.delete_clicked(e),
                content=ft.Row([
                    ft.Icon(ft.Icons.DELETE_OUTLINE_ROUNDED),
                    ft.Text("Delete", weight=ft.FontWeight.BOLD, color=ft.Colors.ON_SURFACE, expand=True),
                ]),
            ),
        ]
    
    # Called when mouse enters our timeline area
    def on_enter(self, e: ft.HoverEvent = None):
        ''' Highlights our timeline control for visual feedback '''

        # During hover, set our x position so we know where to add new items on the timeline
        if e is not None:
            self.x_alignment = (e.control.data - 100) / 100

        # Make the edges highlight
        self.timeline_left_edge.content.color = ft.Colors.with_opacity(1, self.data.get('color', "primary"))
        self.timeline_right_edge.content.color = ft.Colors.with_opacity(1, self.data.get('color', "primary"))

        # Make the main timeline control highlight
        for control in self.timeline_control.content.controls:
            if isinstance(control, ft.GestureDetector):
                control.content.color = ft.Colors.with_opacity(1, self.data.get('color', "primary"))

        # Apply the update
        self.p.update()

    # Called when mouse exits our timeline area
    def on_exit(self, e: ft.HoverEvent):
        ''' Un-highlights our timeline control for visual feedback '''
        
        self.timeline_left_edge.content.color = ft.Colors.with_opacity(.7, self.data.get('color', "primary"))
        self.timeline_right_edge.content.color = ft.Colors.with_opacity(.7, self.data.get('color', "primary"))

        for control in self.timeline_control.content.controls:
            if isinstance(control, ft.GestureDetector):
                control.content.color = ft.Colors.with_opacity(0.7, self.data.get('color', "primary"))

        self.p.update()

    def new_item_clicked(self, e):
        ''' Called when new arc is clicked from timeline context menu '''
        #self.create_arc("New Arc")
        #self.new_item_container.visible = True
        self.story.close_menu()

        tag = e.control.data

        #self.story.open_new_item_input(self.new_item_container)
        #self.p.update()

        # Show our textfield to enter the name of the new item, giving it default based name on length of those num items
        # On submit runs its rename function to create the new item

        if tag is not None:
            if tag == "arc":
                self.create_arc(f"Arc {len(self.arcs) + 1}")
            elif tag == "plot_point":
                self.create_plot_point(f"Plot Point {len(self.plot_points) + 1}")
        else:
            print("Error: No tag found for new item creation")

    


    # Called when rename button is clicked
    def rename_clicked(self, e):
        ''' Makes sure our information display is visible, and focuses the title control for renaming '''

        # Close the menu
        self.story.close_menu()

        # Make sure our information display is visible
        if not self.information_display.visible:
            self.information_display.toggle_visibility(value=True)

        # Focus the title control for renaming
        self.information_display.title_control.focus()

    # Called when color button is clicked
    def get_color_options(self) -> list[ft.Control]:
        ''' Returns a list of all available colors for icon changing '''

        # Called when a color option is clicked on popup menu to change icon color
        def _change_icon_color(color: str):
            ''' Passes in our kwargs to the widget, and applies the updates '''

            # Change the data
            self.data['color'] = color
            self.save_dict()
            
            # Change our icon to match, apply the update
            self.story.active_rail.content.reload_rail()
            self.reload_widget()
            

        # List for our colors when formatted
        color_controls = [] 

        # Create our controls for our color options
        for color in colors:
            color_controls.append(
                ft.PopupMenuItem(
                    content=ft.Text(color.capitalize(), weight=ft.FontWeight.BOLD, color=color),
                    on_click=lambda e, col=color: _change_icon_color(col)
                )
            )

        return color_controls
        

    # Called when the delete button is clicked in the menu options
    def delete_clicked(self, e):
        ''' Deletes this file from the story '''

        def _delete_confirmed(e):
            ''' Deletes the widget after confirmation '''

            self.p.close(dlg)
            self.story.delete_widget(self)

        self.story.close_menu()
            

        # Append an overlay to confirm the deletion
        dlg = ft.AlertDialog(
            title=ft.Text(f"Are you sure you want to delete {self.title} forever?", weight=ft.FontWeight.BOLD),
            alignment=ft.alignment.center,
            title_padding=ft.padding.all(25),
            actions=[
                ft.TextButton("Cancel", on_click=lambda e: self.p.close(dlg)),
                ft.TextButton("Delete", on_click=_delete_confirmed, style=ft.ButtonStyle(color=ft.Colors.ERROR)),
            ]
        )

        self.p.open(dlg)

    # Called when we need to rebuild out timeline UI
    def reload_widget(self):

        # Rebuild our tab to reflect any changes
        self.reload_tab()
        
        # TODO:
        # Don't let delete timeline if only one left
        # Clicking brings up a mini-menu in the timelines widget to show details and allow editing
        # Timeline object and all its children are gesture detectors
        # If event (pp, arc, etc.) is clicked on left side of screen bring mini widgets on right side, and vise versa
        # Time label is optional. Label vertial markers along the timeline with int and label if user provided


        # UI elements
        filters = ft.Row(scroll="auto", alignment=ft.MainAxisAlignment.START)     # Row to hold our filter options
        filter_plot_points = ft.Checkbox(label="Show Plot Points", value=True)      # Checkbox to filter plot points
        filter_arcs = ft.Checkbox(label="Show Arcs", value=True)                    # Checkbox to filter arcs
        reset_zoom_button = ft.ElevatedButton("Reset Zoom", on_click=lambda e: print("reset zoom pressed"))         # Button to reset zoom level

        # Add our filter options to the filters row
        filters.controls = [filter_plot_points, filter_arcs]

        # Header that shows our filter options, as well as what timeliness are visible
        # Add reset zoom button later
        header = ft.Row(
            #wrap=True,     # Want to wrap when lots of filters, but forces into column instead of row
            alignment=ft.MainAxisAlignment.CENTER,
            scroll="auto",
            controls=[reset_zoom_button, filters],
        )

        self.timeline_left_edge.content.color = ft.Colors.with_opacity(0.7, self.data.get('color', "primary"))
        self.timeline_right_edge.content.color = ft.Colors.with_opacity(0.7, self.data.get('color', "primary"))

        
        # Row to hold our timeline edges and control
        timeline_row = ft.Row(
            spacing=0,
            controls=[
                ft.Container(width=20),
                self.timeline_left_edge,
                self.timeline_control,
                self.timeline_right_edge,
                ft.Container(width=20),
            ]
        )

        # Reset the content of our timeline control so we can rebuild it
        self.timeline_control.content = ft.Row(spacing=0, expand=True)

        # Called right after this to give us our list of division positions
        def _set_division_list(total: int)-> list[int]:

            # Calculate step size based on total width and number of divisions
            step = total / self.data.get('divisions', 10)

            # Our list may initially a float if not divisible evenly
            float_list = [i * step for i in range(self.data.get('divisions', 10) + 1)]

            # Convert to int list
            int_list = [int(i) for i in float_list]

            # Remove first and last item in list so we don't double up edges
            int_list = int_list[1:-1]

            # Return our list
            return int_list

        # Set our division list
        division_list = _set_division_list(201)

        # Add line segments so our timeline control isn't just flat
        for i in range(201):

            # Track if we are on a division
            not_division = True

            # Go through our divisions list. If we are on there, add vertical line, then break and continue
            for num in division_list:
                if i == num:
                    # Vertical line only
                    vertical_line = ft.GestureDetector(
                        on_enter=self.on_enter, on_secondary_tap=lambda e: self.story.open_menu(self.get_menu_options()),
                        on_tap=lambda e: self.information_display.toggle_visibility(value=True),
                        height=16, expand=True, 
                        content=ft.VerticalDivider(color=ft.Colors.with_opacity(0.7, self.data.get('color', "primary")), thickness=3, width=3),
                        data=i      # Set our data so we know where to add new items
                    )
                    self.timeline_control.content.controls.append(vertical_line)
                    not_division = False
                    break

            # If we are not a division, add a horizontal line segment
            if not_division:

                # Horizontal followed up by a vertical line
                horizontal_line = ft.GestureDetector(
                    on_enter=self.on_enter, on_secondary_tap=lambda e: self.story.open_menu(self.get_menu_options()),
                    on_tap=lambda e: self.information_display.toggle_visibility(value=True),
                    expand=True, height=16, 
                    content=ft.Divider(color=ft.Colors.with_opacity(0.7, self.data.get('color', "primary")), thickness=3), 
                    data=i      # Set our data so we know where to add new items
                )
                self.timeline_control.content.controls.append(horizontal_line)

            else:  
                continue
            


        # Create a stack so we can sit our plotpoints and arcs on our timeline
        timeline_stack = ft.Stack(
            expand=True, 
            alignment=ft.Alignment(0, 0),
            controls=[
                ft.Container(expand=True, ignore_interactions=True),    # Make sure we're expanded
                timeline_row
            ]
        )
        

        # Order arcs by from longest to shortest, so longer arcs are in back (temp)
        sorted_arcs = dict(sorted(self.arcs.items(), key=lambda item: item[1].data['x_alignment_end'] - item[1].data['x_alignment_start'], reverse=True))

        # Handler for timeline resize events
        for arc in sorted_arcs.values():

            # Add the arc control to the timeline stack
            timeline_stack.controls.append(arc.timeline_control)


        # Add our plot points to the timeline (They position themselves)
        for plot_point in self.plot_points.values():    
            
            # Add the plot point control to the timeline stack
            timeline_stack.controls.append(plot_point.timeline_control)


        # MAKE INVISIBLE IN FUTURE, ONLY EDGES ARE VERTICAL LINES
        # The timeline shown under our timeliness that that will display timeskips, etc. 
        timeline = ft.Container(
            margin=ft.margin.all(10),
            expand=True,
            content=ft.Column(
                expand=True,
                alignment=ft.MainAxisAlignment.CENTER,
                controls=[
                    timeline_stack,   
                ]
            )
        )

        # TODO: Make it so not have to rebuild interactive viewer every time??

        # The body that is our interactive viewer, allowing zoom in and out and moving around
        interactive_viewer = ft.InteractiveViewer(
            min_scale=0.1,
            max_scale=5,
            expand=True,
            boundary_margin=ft.margin.all(20),
            #on_interaction_start=lambda e: print(e),
            #on_interaction_end=lambda e: print(e),
            #on_interaction_update=lambda e: print(e),
            content=timeline,
        )

        
        self.body_container.content = ft.Column([
            header,
            timeline,
        ])

        self._render_widget()
    



        
""" WIP """

import flet as ft
from models.story import Story
from ui.rails.rail import Rail
from styles.timelines.timeline_dropdown import Timeline_Dropdown
from styles.timelines.label_dropdown import Label_Dropdown
from styles.timelines.timeline_item import Timeline_Item
from styles.menu_option_style import Menu_Option_Style
from styles.tooltip import Tooltip


# Class is created in main on program startup
class Timelines_Rail(Rail):

    # Constructor
    def __init__(self, page: ft.Page, story: Story):
        
        # Parent constructor
        super().__init__(
            page=page,
            story=story,
            directory_path=story.data['timelines_directory_path'],
        )

        # Drop down we reference when adding new items to that dropdown
        self.active_dropdown: Timeline_Dropdown = None

        # UI elements
        self.top_row_buttons = [
            ft.IconButton(
                tooltip=Tooltip("New Timeline"),
                icon=ft.Icons.TIMELINE_OUTLINED,
                on_click=self.new_item_clicked,
                data="timeline"
            ),
            ft.IconButton(
                tooltip=Tooltip("New Plot Point"),
                icon=ft.Icons.ADD_LOCATION_OUTLINED,
                icon_color=ft.Colors.PRIMARY if len(self.story.timelines) == 1 else ft.Colors.ON_SURFACE_VARIANT,
                disabled=len(self.story.timelines) != 1,    # Set to if no active timeline
                on_click=self.new_item_clicked,
                data="plot_point"
            ),
            ft.IconButton(
                tooltip=Tooltip("New Arc"),
                icon=ft.Icons.ADD_CIRCLE_OUTLINE_OUTLINED,
                icon_color=ft.Colors.PRIMARY if len(self.story.timelines) == 1 else ft.Colors.ON_SURFACE_VARIANT,
                disabled=len(self.story.timelines) != 1,
                on_click=self.new_item_clicked,
                data="arc"
            )
        ]
 
        # Reload our rail to show timelines
        self.reload_rail()
        
    # Called when a new item button or menu option is clicked
    def new_item_clicked(self, e):

        # Grab our tag from the new item clicked event
        tag = e.control.data

        # For timelines
        if tag == "timeline":
            self.new_item_textfield.hint_text = "Timeline Title"
            self.new_item_textfield.data = "timeline"
            self.new_item_textfield.visible = True
            self.new_item_textfield.value = None

        else:

            # For other items, let the dropdown handle the logic
            self.active_dropdown.new_item_clicked(tag=tag)


        # Close the menu (if ones is open), which will update the page as well
        self.story.close_menu()


    # Called to return our list of menu options when right clicking on the timeline rail
    def get_menu_options(self) -> list[ft.Control]:
        ''' Returns our menu options for the timelines rail. In this case just timelines '''

        if len(self.story.timelines) == 1:
            return [
                Menu_Option_Style(
                    on_click=self.new_item_clicked,
                    data="plot_point",
                    content=ft.Row([
                        ft.Icon(ft.Icons.ADD_LOCATION_OUTLINED),
                        ft.Text("Plot Point", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
                Menu_Option_Style(
                    on_click=self.new_item_clicked,
                    data="arc",
                    content=ft.Row([
                        ft.Icon(ft.Icons.CIRCLE_OUTLINED),
                        ft.Text("Arc", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
                Menu_Option_Style(
                    on_click=self.new_item_clicked,
                    data="timeline",
                    content=ft.Row([
                        ft.Icon(ft.Icons.TIMELINE_OUTLINED),
                        ft.Text("Timeline", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
            ]

        else:
            return [
                Menu_Option_Style(
                    on_click=self.new_item_clicked,
                    data="timeline",
                    content=ft.Row([
                        ft.Icon(ft.Icons.ADD_ROUNDED),
                        ft.Text("Timeline", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
            ]
    
    # Called when right clicking a timeline, arc, or the arc/plot point drop downs
    def get_sub_menu_options(self, tag: str=None, is_label: bool=False) -> list[ft.Control]:
        ''' Returns the menu options for our sub items based on its tag '''

        # List we will return at end function
        options = []

        # Depending on what tag we have, return different options. Plot points label just gets plot point option
        if tag == "plot_points_label" and is_label:
            options.append(
                # Create plot point button
                Menu_Option_Style(
                    data="plot_point",
                    content=ft.Row([
                        ft.Icon(ft.Icons.ADD_LOCATION_OUTLINED),
                        ft.Text("Plot Point", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
            )

        # Arcs label just gets arc option
        elif tag == "arcs_label" and is_label:
            options.append(
                # Create arc button
                Menu_Option_Style(
                    data="arc",
                    content=ft.Row([
                        ft.Icon(ft.Icons.CIRCLE_OUTLINED),
                        ft.Text("Arc", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
            )

        else:
            options.extend([
                 # Create plot point button
                Menu_Option_Style(
                    data="plot_point",
                    content=ft.Row([
                        ft.Icon(ft.Icons.ADD_LOCATION_OUTLINED),
                        ft.Text("Plot Point", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
                # Create arc button
                Menu_Option_Style(
                    data="arc",
                    content=ft.Row([
                        ft.Icon(ft.Icons.CIRCLE_OUTLINED),
                        ft.Text("Arc", color=ft.Colors.ON_SURFACE, weight=ft.FontWeight.BOLD),
                    ])
                ),
            ])

        return options
    
    # Refreshes our top row buttons based on our active dropdown
    def refresh_buttons(self, no_active_dropdown: bool=False):
        ''' Refreshes the top row buttons based on our active dropdown/timeline to update our colors and disabled states '''

        # When clicking on the rail, get rid of our active dropdown
        if no_active_dropdown and len(self.story.timelines) != 1:
            self.active_dropdown = None

        # Next, see if our dropdown is just a label. If it is, make the timeline_dropdown it sits inside as our active dropdown
        # We do this so we can add plot points and arcs even from the opposite label dropdown
        if self.active_dropdown is not None:
            if isinstance(self.active_dropdown, Label_Dropdown):
                self.active_dropdown = self.active_dropdown.timeline_dropdown

        # Go through each button and update their color, disabled state, and on click function
        for i, button in enumerate(self.top_row_buttons):

            # Skip the timelines button, its always active and needs no changes
            if i == 0:
                continue

            else:
                
                # Color is primary if we have an active dropdown, otherwise its grey-ish
                button.icon_color = ft.Colors.PRIMARY if self.active_dropdown is not None else ft.Colors.ON_SURFACE_VARIANT

                # Button is disabled if no active dropdown and more than one timeline
                button.disabled = self.active_dropdown is None and len(self.story.timelines) != 1

                # On click function goes to active dropdown logic if we have one, otherwise goes to rail logic
                button.on_click = self.active_dropdown.new_item_clicked if self.active_dropdown is not None else self.new_item_clicked
    
        # Finally, update the page
        self.p.update()
           


    # Reload the rail whenever we need
    def reload_rail(self) -> ft.Control:
        ''' Reloads the plot and timeline rail, useful when switching stories '''

        # WHEN CREATING NEW PP OR ARC, ADD IT DEFAULT TO MIDDLE OF TIMELINE AND BE ABLE TO BE DRAGGED AROUND

        self.refresh_buttons()

        header = ft.Row(
            vertical_alignment=ft.CrossAxisAlignment.CENTER,
            alignment=ft.MainAxisAlignment.CENTER,
            
            controls=self.top_row_buttons
        )

        # Build the content of our rail
        content = ft.Column(
            scroll=ft.ScrollMode.AUTO,
            spacing=0,
            controls=[]
        )

        # Run through each timeline in the story
        for timeline in self.story.timelines.values():

            # Create an expansion tile for our timeline that we need in order to load its data
            timeline.timeline_dropdown = Timeline_Dropdown(
                title=timeline.title, 
                story=self.story, 
                timeline=timeline, 
                additional_menu_options=self.get_sub_menu_options(),
                rail=self
            )

            # Create our timeline dropdowns here in 

            # Load our timeline data
            # New drop down for our plotpoints
            plot_points_dropdown = Label_Dropdown(
                title="Plot Points",
                story=self.story,
                additional_menu_options=self.get_sub_menu_options(tag="plot_points_label", is_label=True),
                timeline=timeline,
                rail=self,
                timeline_dropdown=timeline.timeline_dropdown
            )

        
            # Go through our plotpoints from our timeline, and add each item
            for plot_point in timeline.plot_points.values():
                plot_points_dropdown.content.controls.append(
                    Timeline_Item(title=plot_point.title, mini_widget=plot_point)
                )

            plot_points_dropdown.content.controls.append(plot_points_dropdown.new_item_textfield)

            # Add our plot points dropdown to the timeline dropdown
            timeline.timeline_dropdown.content.controls.append(plot_points_dropdown)

            # New drop down for our arcs
            arcs_dropdown = Label_Dropdown(
                title="Arcs",
                story=self.story,
                additional_menu_options=self.get_sub_menu_options(tag="arcs_label", is_label=True),
                timeline=timeline,
                rail=self,
                timeline_dropdown=timeline.timeline_dropdown
            )
            

            # Go through all the arcs/sub arcs held in our parent arc or timeline
            for arc in timeline.arcs.values():

                arcs_dropdown.content.controls.append(
                    Timeline_Item(title=arc.title, mini_widget=arc)
                )

            arcs_dropdown.content.controls.append(arcs_dropdown.new_item_textfield)


            # Add our arcs dropdown to the timeline dropdown
            timeline.timeline_dropdown.content.controls.append(arcs_dropdown)


            # Add some padding under it between timelines
            #timeline.timeline_dropdown.content.controls.append(ft.Container(height=10))

            # If theres only one timeline, no need to add the parent expansion to the page.
            if len(self.story.timelines) == 1:

                # If only one timeline, just add its content directly to the rail rather than making it a dropdown
                content.controls.extend(timeline.timeline_dropdown.content.controls)

                # Set our active_dropdown if we only have one
                self.active_dropdown = timeline.timeline_dropdown

            # Otherwise, add the full expansion panel
            else:
                content.controls.append(timeline.timeline_dropdown)
    
        content.controls.append(ft.Container(height=6))

        # Finally, add our new item textfield at the bottom
        content.controls.append(self.new_item_textfield)

        

        # Gesture detector to put on top of stack on the rail to pop open menus on right click
        gd = ft.GestureDetector(
            expand=True,
            on_secondary_tap=lambda e: self.story.open_menu(self.get_menu_options()),
            content=content,
            #on_tap=lambda e: self.refresh_buttons(no_active_dropdown=True)
        )

        # Set our content to be a column
        self.content = ft.Column(
            spacing=0,
            expand=True,
            controls=[
                header,
                ft.Divider(),
                gd
            ]
        )

        # Make sure our buttons are refreshed
        self.refresh_buttons()

        # Apply the changes to the page
        self.p.update()


    

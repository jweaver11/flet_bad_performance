'''
UI styling for the main workspace area of appliction that holds our widgets (tabs)
Returns our container with our formatting areas inside the workspace area.
The stories 'mast_stack' holds our 'master_row', which contains our five pins: top, left, main, right, and bottom.
Overtop that, we append our drag targets when we start dragging a widget (tab). Thats why its a stack
'''

import flet as ft
from models.app import app
from models.story import Story
import json


# Our workspace object that is stored in our story object
class Workspace(ft.Container):
    # Constructor
    def __init__(self, page: ft.Page, story: Story):

        # Set our container properties for the workspace
        super().__init__(
            expand=True,
            alignment=ft.alignment.center,
            bgcolor=ft.Colors.with_opacity(1, ft.Colors.SURFACE),
            padding=ft.padding.all(10),
        )

        self.p = page
        self.story = story

        self.minimum_pin_height = 200
        self.minimum_pin_width = 230

        # Creates our 5 pin locations for our widgets inside our workspace
        self.top_pin = ft.Row(spacing=10, height=story.data['top_pin_height'], controls=[])
        self.left_pin = ft.Column(spacing=10, width=story.data['left_pin_width'], controls=[])
        self.main_pin = ft.Row(expand=True, spacing=10, controls=[])
        self.right_pin = ft.Column(spacing=10, width=story.data['right_pin_width'], controls=[])
        self.bottom_pin = ft.Row(spacing=10, height=story.data['bottom_pin_height'], controls=[])

        # Add our settings to the main pin whenver a new story is loaded or created
        self.main_pin.controls.append(app.settings)

        # Our master row that holds all our widgets
        self.widgets = ft.Row(spacing=0, expand=True, controls=[])

        # Master stack that holds our widgets ^ row. We add our drag targets overtop our widgets, so we use a stack here
        # And our drag targets when we start dragging widgets.
        # We use global stack like this so there is always a drag target, even if a pin is empty
        self.master_stack = ft.Stack(expand=True, controls=[self.widgets])

        # Pin drag targets
        self.top_pin_drag_target = ft.DragTarget(
            group="widgets", 
            content=ft.Container(expand=True, bgcolor=ft.Colors.WHITE, opacity=0), 
            on_accept=lambda e: self.pin_drag_accept(e, "top"), on_will_accept=self.on_hover_pin_drag_target, on_leave=self.on_stop_hover_drag_target,
        )
        self.left_pin_drag_target = ft.DragTarget(
            group="widgets",
            content=ft.Container(expand=True, width=self.minimum_pin_width, bgcolor=ft.Colors.WHITE, opacity=0), 
            on_accept=lambda e: self.pin_drag_accept(e, "left"), on_will_accept=self.on_hover_pin_drag_target, on_leave=self.on_stop_hover_drag_target,
        )
        self.main_pin_drag_target = ft.DragTarget(
            group="widgets", 
            content=ft.Container(expand=True, height=self.minimum_pin_height, bgcolor=ft.Colors.WHITE, opacity=0), 
            on_accept=lambda e: self.pin_drag_accept(e, "main"), on_will_accept=self.on_hover_pin_drag_target, on_leave=self.on_stop_hover_drag_target,
        )
        self.right_pin_drag_target = ft.DragTarget(
            group="widgets", 
            content=ft.Container(expand=True, width=self.minimum_pin_width, bgcolor=ft.Colors.WHITE, opacity=0), 
            on_accept=lambda e: self.pin_drag_accept(e, "right"), on_will_accept=self.on_hover_pin_drag_target, on_leave=self.on_stop_hover_drag_target,
        )
        self.bottom_pin_drag_target = ft.DragTarget(
            group="widgets", 
            content=ft.Container(expand=True, height=self.minimum_pin_height, bgcolor=ft.Colors.WHITE, opacity=0),
            on_accept=lambda e: self.pin_drag_accept(e, "bottom"), on_will_accept=self.on_hover_pin_drag_target, on_leave=self.on_stop_hover_drag_target,
        )

        self.pin_drag_targets = [
            ft.Container(
                expand=True,
                content=self.main_pin_drag_target,
                top=200, left=200, right=200, bottom=200, 
            ),
            ft.Container(
                content=self.top_pin_drag_target,
                height=200,
                top=0, left=0, right=0, 
            ),
            ft.Container(
                content=self.bottom_pin_drag_target,
                height=200,
                bottom=0, left=0, right=0,
            ),
            ft.Container(
                content=self.left_pin_drag_target,
                width=220,
                left=0, top=0, bottom=0,
            ),
            ft.Container(
                content=self.right_pin_drag_target,
                width=220,
                right=0, top=0, bottom=0, 
            ),
        ]


        # We call this in the story build_view, since it errors out here if the object is not fully built yet
        #self.reload_workspace() 

    # When a draggable starts dragging, we add our drag targets to the master stack
    def show_pin_drag_targets(self):
        ''' Adds our drag targets to the master stack so we can drop our widgets into pin locations '''

        # Add logic here. pin drag targets.width = left_pin.width if left_pin.width > minimum_pin_width else minimum_pin_width

        if self.pin_drag_targets not in self.master_stack.controls:
            self.master_stack.controls.extend(self.pin_drag_targets)
            self.master_stack.update()

        self.p.update()

    # Called whenever a drag target accepts a draggable
    def remove_drag_targets(self):
        ''' Removes our drag targets from the master stack, otherwise they sit overtop our widgets and get in the way '''

        for target in self.pin_drag_targets:
            if target in self.master_stack.controls:
                self.master_stack.controls.remove(target)
        self.master_stack.update()

    # Called when a draggable hovers over a drag target before dropping
    def on_hover_pin_drag_target(self, e):
        ''' Makes the drag target visible for so visual feedback '''

        e.control.content.opacity = .5
        e.control.content.update()
       
    # Called when a draggable leaves a drag target
    def on_stop_hover_drag_target(self, e):
        ''' Makes the drag target invisible again '''

        e.control.content.opacity = 0
        e.control.content.update()
        
    # Accepting drags for our five pin locations
    def pin_drag_accept(self, e, pin_location: str):

        # Reset our container to be invisible again
        e.control.content.opacity = 0
        e.control.content.update()

        self.remove_drag_targets()  # Remove our drag targets from the stack, since we have completed our drag

        # Load our event data
        event_data = json.loads(e.data)
        # Save the src id from the data so we can find our draggable
        src_id = event_data.get("src_id")
        
        # Save our draggable so we can load its data
        draggable = e.page.get_control(src_id)
            
        # Set object variable to our object
        widget = draggable.data

        old_pin_location = widget.data['pin_location']

        # If we were dragged from the main pin and we were the active tab, set the first tab to new active
        if old_pin_location == "main" and widget.data['is_active_tab'] == True:

            # If there are other widgets in the main pin, set the first one to active tab
            self.story.workspace.main_pin.controls[0].data['is_active_tab'] = True
            self.story.workspace.main_pin.controls[0].save_dict()
                
                

        # Set our objects pin location to the correct new location
        widget.data['pin_location'] = pin_location  

        # Even though we're not in the new pin location until we reload, we can just use the length to find our index
        if pin_location == "top":
            widget.data['index'] = len(self.story.workspace.top_pin.controls)
        
        elif pin_location == "left":
            widget.data['index'] = len(self.story.workspace.left_pin.controls)
        
        elif pin_location == "main":
            widget.data['index'] = len(self.story.workspace.main_pin.controls)   

            # Set other tabs to inactive, and new one to active              
            for w in self.story.workspace.main_pin.controls:
                w.data['is_active_tab'] = False        # Deselect all other main pin widgets

            widget.data['is_active_tab'] = True

        elif pin_location == "right":
            widget.data['index'] = len(self.story.workspace.right_pin.controls)

        elif pin_location == "bottom":
            widget.data['index'] = len(self.story.workspace.bottom_pin.controls)


        
        # Make sure our widget is visible if it was dragged from the rail
        if not widget.visible:
            widget.toggle_visibility(value=True)      # This will save dict as well
        else:
            widget.save_dict()  

        # Apply to UI
        self.reload_workspace()

        # Reload our widget to apply size changes that some of them need
        widget.reload_widget()
        
        print(f"{pin_location} pin accepted")

    # Called when we drag a widget from one pin location to another
    def arrange_widgets(self):
        ''' Arranges our widgets to their correct pin locations after a change is made to their pin location.
        Also adds widgets to their correct pin locations if they are missing from any pin location '''

        story = self.story
        
        try:

            # Clear all pin locations first
            story.workspace.top_pin.controls.clear()
            story.workspace.left_pin.controls.clear()
            story.workspace.main_pin.controls.clear()
            story.workspace.right_pin.controls.clear()
            story.workspace.bottom_pin.controls.clear()

            # Lets widgets keep their order between sessions
            ordered_widgets = sorted(story.widgets, key=lambda w: w.data.get('index', 0))

            # Go through all our widgets in the story
            for widget in ordered_widgets:

                # Check if they are visible
                if widget.visible == True:

                    # Check if widget has data and pin_location
                    if hasattr(widget, 'data') and widget.data and 'pin_location' in widget.data:
                        pin_location = widget.data['pin_location']
                        
                        # Add widget to the correct pin based on its pin_location
                        if pin_location == "top":
                            story.workspace.top_pin.controls.append(widget)
                            widget.data['index'] = story.workspace.top_pin.controls.index(widget)
                        elif pin_location == "left":
                            story.workspace.left_pin.controls.append(widget)
                            widget.data['index'] = story.workspace.left_pin.controls.index(widget)
                        elif pin_location == "main":
                            story.workspace.main_pin.controls.append(widget)
                            widget.data['index'] = story.workspace.main_pin.controls.index(widget)
                        elif pin_location == "right":
                            story.workspace.right_pin.controls.append(widget)
                            widget.data['index'] = story.workspace.right_pin.controls.index(widget)
                        elif pin_location == "bottom":
                            story.workspace.bottom_pin.controls.append(widget)
                            widget.data['index'] = story.workspace.bottom_pin.controls.index(widget)
                            
                    else:
                        # If no valid pin_location, default to main pin
                        if widget not in story.workspace.main_pin.controls:
                            print("Invalid pin location, adding to main pin")
                            story.workspace.main_pin.controls.append(widget)
                            
                # Skip non visible widgets
                else:
                    continue

            # If main pin is empty, steal one from other pins so we are always fullscreen
            if len(story.workspace.main_pin.controls) == 0:

                # Steal from left first
                if len(story.workspace.left_pin.controls) > 0:
                    # Copy and delete last widget in left pin
                    widget = story.workspace.left_pin.controls.pop()
                    story.workspace.main_pin.controls.append(widget)
                # Right pin
                elif len(story.workspace.right_pin.controls) > 0:
                    widget = story.workspace.right_pin.controls.pop()
                    story.workspace.main_pin.controls.append(widget)
                # Top pin
                elif len(story.workspace.top_pin.controls) > 0:
                    widget = story.workspace.top_pin.controls.pop()
                    story.workspace.main_pin.controls.append(widget)
                # Bottom pin
                elif len(story.workspace.bottom_pin.controls) > 0:
                    widget = story.workspace.bottom_pin.controls.pop()
                    story.workspace.main_pin.controls.append(widget)
                else:
                    pass

                # If we stole a widget, make its data match its new location
                if widget is not None:
                    widget.data['pin_location'] = "main"
                    widget.save_dict()

        except Exception as e:
            print(f"Error arranging widgets: {e}")

    # Called when we need to reload our workspace content, especially after pin drags
    def reload_workspace(self):
        ''' Reloads our workspace content by clearing and re-adding our 5 pin locations to the master row '''
        from models.widget import Widget

        # Make sure our widgets are arranged correctly
        self.arrange_widgets()

        # Change our cursor when we hover over a resizer (divider). Either vertical or horizontal
        def show_vertical_cursor(e: ft.HoverEvent):
            e.control.mouse_cursor = ft.MouseCursor.RESIZE_UP_DOWN
            e.control.update()
        def show_horizontal_cursor(e: ft.HoverEvent):
            e.control.mouse_cursor = ft.MouseCursor.RESIZE_LEFT_RIGHT
            e.control.update()


        # Rendering adds dividers between each widget. So if we remove old ones here
        self.top_pin.controls = [control for control in self.top_pin.controls if type(control) != ft.GestureDetector]
        self.left_pin.controls = [control for control in self.left_pin.controls if type(control) != ft.GestureDetector]
        self.right_pin.controls = [control for control in self.right_pin.controls if type(control) != ft.GestureDetector]
        self.bottom_pin.controls = [control for control in self.bottom_pin.controls if type(control) != ft.GestureDetector]

        

        
        


        # Method called when our divider (inside a gesture detector) is dragged
        # Updates the size of our pin in the story object
        def move_top_pin_divider(e: ft.DragUpdateEvent):
            #print("move top pin divider called")
            if (e.delta_y > 0 and self.top_pin.height < self.p.height/2) or (e.delta_y < 0 and self.top_pin.height > 200):
                self.top_pin.height += e.delta_y
                self.top_pin_drag_target.content.height = self.top_pin.height  # Update the drag target height to match the pin height
            formatted_top_pin.update()
            self.widgets.update() # Update the main pin, as it is affected by all pins resizing
            self.master_stack.update()
        def save_top_pin_height(e: ft.DragEndEvent):
            #print("save top pin height called")
            self.story.data['top_pin_height'] = self.top_pin.height
            self.story.save_dict()

            # Reload each widget in the top pin to apply size changes if they need it
            for widget in self.top_pin.controls:
                if isinstance(widget, Widget):
                    widget.reload_widget()   

            # Also update the main pin widgets
            for widget in self.main_pin.controls:
                widget.reload_widget() 
            

        # The control that holds our divider, which we drag to resize the top pin
        top_pin_resizer = ft.GestureDetector(
            content=ft.Container(
                height=10,
                bgcolor=ft.Colors.TRANSPARENT,
                padding=ft.padding.only(top=8),  # Push the 2px divider to the right side
                #content=ft.Divider(thickness=2, height=2, color=ft.Colors.PRIMARY, opacity=.5)
            ),
            on_pan_update=move_top_pin_divider,
            on_pan_end=save_top_pin_height,
            on_hover=show_vertical_cursor,
            drag_interval=10,
        )

        # Left pin reisizer method and variable
        def move_left_pin_divider(e: ft.DragUpdateEvent):
            #print("move left pin divider called")
            if (e.delta_x > 0 and self.left_pin.width < self.p.width/2) or (e.delta_x < 0 and self.left_pin.width > 200):
                self.left_pin.width += e.delta_x
            formatted_left_pin.update()
            self.widgets.update()
            self.master_stack.update()
        def save_left_pin_width(e: ft.DragEndEvent):
            #print("save left pin width called")
            self.story.data['left_pin_width'] = self.left_pin.width
            self.story.save_dict()
            # Reload each widget in the top pin to apply size changes if they need it
            for widget in self.left_pin.controls:
                if isinstance(widget, Widget):
                    widget.reload_widget()     
            for widget in self.main_pin.controls:
                widget.reload_widget() 
        left_pin_resizer = ft.GestureDetector(
            content=ft.Container(
                width=10,
                bgcolor=ft.Colors.TRANSPARENT,
                padding=ft.padding.only(left=8),  # Push the 2px divider to the right side
                #content=ft.VerticalDivider(thickness=2, width=2, color=ft.Colors.PRIMARY, opacity=.5)
            ),
            on_pan_update=move_left_pin_divider,
            on_pan_end=save_left_pin_width,
            on_hover=show_horizontal_cursor,
            drag_interval=10,
        )
        
        # No resizer for main pin, as it is always expanded and takes up the rest of the space

        # Right pin resizer method and variable
        def move_right_pin_divider(e: ft.DragUpdateEvent):
            #print("move right pin divider called")
            if (e.delta_x < 0 and self.right_pin.width < self.p.width/2) or (e.delta_x > 0 and self.right_pin.width > 200):
                self.right_pin.width -= e.delta_x
            formatted_right_pin.update()
            self.widgets.update()
            self.master_stack.update()
        def save_right_pin_width(e: ft.DragEndEvent):
            print("save right pin width called")    
            self.story.data['right_pin_width'] = self.right_pin.width
            print("right pin width saved as:", self.right_pin.width)
            self.story.save_dict()
            # Reload each widget in the top pin to apply size changes if they need it
            for widget in self.right_pin.controls:
                if isinstance(widget, Widget):
                    widget.reload_widget()   
            for widget in self.main_pin.controls:
                widget.reload_widget() 
        right_pin_resizer = ft.GestureDetector(
            content=ft.Container(
                width=10,
                bgcolor=ft.Colors.TRANSPARENT,
                padding=ft.padding.only(left=8),  # Push the 2px divider to the right side
                #content=ft.VerticalDivider(thickness=2, width=2, color=ft.Colors.PRIMARY, opacity=.5)
            ),
            on_pan_update=move_right_pin_divider,
            on_pan_end=save_right_pin_width,
            on_hover=show_horizontal_cursor,
            drag_interval=10,
        )

        # Bottom pin resizer method and variable
        def move_bottom_pin_divider(e: ft.DragUpdateEvent):
            #print("move bottom pin divider called")
            if (e.delta_y < 0 and self.bottom_pin.height < self.p.height/2) or (e.delta_y > 0 and self.bottom_pin.height > 200):
                self.bottom_pin.height -= e.delta_y
            formatted_bottom_pin.update()
            self.widgets.update()
            self.master_stack.update()
        def save_bottom_pin_height(e: ft.DragEndEvent):
            print("save bottom pin height called")
            self.story.data['bottom_pin_height'] = self.bottom_pin.height
            self.story.save_dict()
            # Reload each widget in the top pin to apply size changes if they need it
            for widget in self.bottom_pin.controls:
                if isinstance(widget, Widget):
                    widget.reload_widget()   
            for widget in self.main_pin.controls:
                widget.reload_widget() 
        bottom_pin_resizer = ft.GestureDetector(
            content=ft.Container(
                height=10,
                bgcolor=ft.Colors.TRANSPARENT,
                padding=ft.padding.only(top=8),  # Push the 2px divider to the right side
                #content=ft.Divider(thickness=2, height=2, color=ft.Colors.PRIMARY, opacity=.5)
            ),
            on_pan_update=move_bottom_pin_divider,
            on_pan_end=save_bottom_pin_height,
            on_hover=show_vertical_cursor,
            drag_interval=10,
        )

        # Called when selected new tab in the main pin
        def main_pin_tab_change(e: ft.ControlEvent):
            ''' Updates the widgets data to reflect the new active tab '''


            # Run through our visible main pin widgets
            for widget in visible_main_controls:

                # If the widgets tab is selected, make the widget data match, otherwise deselect the rest
                if widget.tab == e.control.tabs[e.control.selected_index]:
                    widget.data['is_active_tab'] = True
                    self.main_pin_tabs.indicator_color = widget.data.get('color', ft.Colors.PRIMARY)
                else:
                    widget.data['is_active_tab'] = False

                # Save the data. This allows for selected main pin tabs to save between sessions
                widget.save_dict()

            self.p.update()



        # Main pin is rendered as a tab control, so we won't use dividers and will use different logic
        visible_main_controls = [control for control in self.main_pin.controls if getattr(control, 'visible', True)]
        #print(f"Visible main pin controls: {len(visible_main_controls)}")
        if len(visible_main_controls) > 1:


            # PC: Save tabs as variable, change active color to match widget color when tab change
                
            # Temporary
            self.main_pin_tabs = ft.Tabs(
                animation_duration=0,
                on_change=main_pin_tab_change,
                expand=True,  # Layout engine breaks Tabs inside of Columns if this expand is not set
                #divider_color=ft.Colors.TRANSPARENT,
                padding=ft.padding.all(0),
                label_padding=ft.padding.all(0),
                mouse_cursor=ft.MouseCursor.BASIC,
                
                tabs=[]    # Gives our tab control here   
            )
            for widget in visible_main_controls:
                self.main_pin_tabs.tabs.append(widget.tab)
                #print("Added tab for widget:", widget.data.get('title', 'Untitled'))
                # Sets the selected tab to the active one in the main pin
                if widget.data['is_active_tab']:
                    self.main_pin_tabs.selected_index = self.main_pin_tabs.tabs.index(widget.tab)
                    self.main_pin_tabs.indicator_color =  ft.Colors.with_opacity(0.8, widget.data.get('color', ft.Colors.PRIMARY))
                    

            # Stick it in a container for styling
            formatted_main_pin = ft.Container(
                
                expand=True, 
            
                border_radius=ft.border_radius.all(8),
            
                gradient=ft.LinearGradient(
                    begin=ft.alignment.top_center,
                    end=ft.alignment.bottom_center,
                    colors=[
                        ft.Colors.with_opacity(0.6, ft.Colors.ON_INVERSE_SURFACE),
                        ft.Colors.with_opacity(0.2, ft.Colors.ON_INVERSE_SURFACE),
                    ],
                ),
                animate=ft.Animation(300, ft.AnimationCurve.EASE_OUT),
                margin=ft.margin.all(0),
                #padding=ft.padding.all(8),
                padding=ft.padding.only(top=0, bottom=8, left=8, right=8),
                    content=self.main_pin_tabs
                )

            #print(len(tabs.tabs), " tabs added to main pin")

        else:
            formatted_main_pin = self.main_pin


        print("Initial selected main pin tab index:", getattr(self.main_pin_tabs, 'selected_index', 'N/A')  )

        


        
        # Formatted pin locations that hold our pins, and our resizer gesture detectors.
        # Main pin is always expanded and has no resizer, so it doesnt need to be formatted
        formatted_top_pin = ft.Column(spacing=0, controls=[self.top_pin, top_pin_resizer])
        formatted_left_pin = ft.Row(spacing=0, controls=[self.left_pin, left_pin_resizer]) 
        formatted_right_pin = ft.Row(spacing=0, controls=[right_pin_resizer, self.right_pin])  # Right pin formatting row
        formatted_bottom_pin = ft.Column(spacing=0, controls=[bottom_pin_resizer, self.bottom_pin])  # Bottom pin formatting column

        # Check if our pins have any visible widgets or not, so if they should show up on screen
        # Check if top pin is empty. If yes, hide the formatted pin
        if len(self.top_pin.controls) == 0:
            formatted_top_pin.visible = False
        # If top pin not empty, make sure there is at least one visible widget
        elif all(obj.visible == False for obj in self.top_pin.controls[:]):
            formatted_top_pin.visible = False
        else:   # If not empty, check if any of the widgets are visible
            for obj in self.top_pin.controls:
                if obj.visible == True:     # If any widgets are visible, show our formatted pin
                    formatted_top_pin.visible = True
                    break   # No need to keep checking if at least one is visible
            # Makes sure our height is set correctly
            if self.top_pin.height < self.minimum_pin_height:
                self.top_pin.height = self.minimum_pin_height

        # Left pin
        if len(self.left_pin.controls) == 0:
            formatted_left_pin.visible = False
        elif all(obj.visible == False for obj in self.left_pin.controls[:]):
            formatted_left_pin.visible = False
        else:
            for obj in self.left_pin.controls:
                if obj.visible == True:
                    formatted_left_pin.visible = True
                    break
            if self.left_pin.width < self.minimum_pin_width:
                self.left_pin.width = self.minimum_pin_width

        # Right pin
        if len(self.right_pin.controls) == 0:
            formatted_right_pin.visible = False
        elif all(obj.visible == False for obj in self.right_pin.controls[:]):
            formatted_right_pin.visible = False
        else:
            for obj in self.right_pin.controls:
                if obj.visible == True:
                    formatted_right_pin.visible = True
                    break
            if self.right_pin.width < self.minimum_pin_width:
                self.right_pin.width = self.minimum_pin_width

        # Bottom pin
        if len(self.bottom_pin.controls) == 0:
            formatted_bottom_pin.visible = False
        elif all(obj.visible == False for obj in self.bottom_pin.controls[:]):
            formatted_bottom_pin.visible = False
        else:
            for obj in self.bottom_pin.controls:
                if obj.visible == True:
                    formatted_bottom_pin.visible = True
                    break
            if self.bottom_pin.height < self.minimum_pin_height:
                self.bottom_pin.height = self.minimum_pin_height

        # Format our pins on the page
        self.widgets.controls.clear()
        self.widgets.controls = [
            formatted_left_pin,    # formatted left pin
            ft.Column(
                expand=True, spacing=0, 
                controls=[
                    formatted_top_pin,    # formatted top pin
                    #self.main_pin,     # main work area with widgets
                    formatted_main_pin,   # formatted main pin
                    formatted_bottom_pin,     # formatted bottom pin
            ]),
            formatted_right_pin,    # formatted right pin
        ]

        # Set the master_stack as the content of this container
        self.content = self.master_stack
        
        
        # Finally update the UI
        self.p.update()


        



# Called to create our workspace whenever there is NO active story or no stories at all
def create_workspace(page: ft.Page) -> ft.Container:   

    # Called when giant new story button is clicked
    def create_new_story_button_clicked(e):
        ''' Opens a dialog to create a new story. Checks story is unique or not '''
        #print("New Story Clicked")

        # Variable to track if the title is unique
        is_unique = True

        # Called by clicking off the dialog or cancel button
        def close_dialog(e):
            ''' Closes the dialog '''
            dlg.open = False
            page.update()

        def submit_new_story(e):
            ''' Creates a new story with the given title '''

            # Import our variable if it is unique or nah
            nonlocal is_unique

            if isinstance(e, ft.TextField):
                title = e.value
            else:
                title = e.control.value

            print(title)

            for story in app.stories.values():
                if story.title == title:
                    is_unique = False
                    break

            # Check if the title is unique
            if is_unique:
                #print("title is unique, story being created: ", title)
                app.create_new_story(title, page, "default") # Needs the story object
                dlg.open = False
                page.update()
            else:
                #print("Title not unique, no story created")
                story_title_field.error_text = "Title must be unique"
                story_title_field.focus()   # refocus the text field since the title was not unique
                page.update()


        # Called everytime the user enters a new letter in the text box
        def textbox_value_changed(e):
            ''' Called when the text in the text box changes '''

            nonlocal is_unique

            # Checks if the title sitting in the text box is unique for submitting
            title = e.control.value
            for story in app.stories.values():
                if story.title == title:
                    e.control.error_text = "Title must be unique"
                    is_unique = False
                    page.update()
                    return
                else:
                    e.control.error_text = None
                    is_unique = True
                    page.update()

            
            #print(f"New story created with title: {title}")

        # Create a reference to the text field so we can access its value
        story_title_field = ft.TextField(
            label="Story Title",
            autofocus=True,
            on_submit=submit_new_story,
            on_change=textbox_value_changed,
        )
            
        # The dialog that will pop up whenever the new story button is clicked
        dlg = ft.AlertDialog(

            # Title of our dialog
            title=ft.Text("Create New Story"),

            # Main content is text box for user to input story title
            content=story_title_field,

            # Our two action buttons at the bottom of the dialog
            actions=[
                ft.TextButton("Cancel", on_click=close_dialog, style=ft.ButtonStyle(color=ft.Colors.ERROR)),
                ft.TextButton("Create", on_click=lambda e: submit_new_story(story_title_field)),
            ],
        )

        # Open our dialog in the overlay
        dlg.open = True
        page.overlay.append(dlg)
        page.update()


    
    return ft.Container(
        expand=True,
        alignment=ft.alignment.center,
        bgcolor=ft.Colors.with_opacity(0.4, ft.Colors.ON_INVERSE_SURFACE),
        content=ft.FloatingActionButton(
            icon=ft.Icons.ADD,
            text="No Active Story\nClick to Create New Story",
            on_click=create_new_story_button_clicked,
            width=200,
            height=100,
            shape=ft.RoundedRectangleBorder(radius=10),  
        ),
    )